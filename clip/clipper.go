// Package clip provides an implementation for clipping polygons.
// Currently the only implementation is using the github.com/aligator/go.clipper library.
package clip

import (
	"GoSlice/data"
	clipper "github.com/aligator/go.clipper"
)

type Pattern interface {
	// Fill fills the given paths.
	// The parameter overlapPercentage should normally be a value between 0 and 100.
	// But it can also be smaller or greater than that if needed.
	// The generated infill will overlap the paths by the percentage of this param.
	// The additionalInternalOverlap is added to the overlap before the resulting infill is  clipped by the outline.
	// LineWidth is used for both, the calculation of the overlap and the calculation between the lines.
	Fill(layerNr int, paths data.LayerPart, outline data.LayerPart, lineWidth data.Micrometer, overlapPercentage int, additionalInternalOverlap int) data.Paths
}

// Clipper is an interface that provides methods needed by GoSlice to clip polygons.
type Clipper interface {
	// GenerateLayerParts partitions the whole layer into several partition parts.
	GenerateLayerParts(l data.Layer) (data.PartitionedLayer, bool)

	// InsetLayer returns all new paths generated by insetting all parts of the layer.
	// The result is built the following way: [part][insetNr][insetParts]data.LayerPart
	//
	//  * Part is the part in the from the input-layer.
	//  * Wall is the wall of the part. The first wall is the outer perimeter.
	//  * InsetNum is the number of the inset (starting by the outer walls with 0)
	//    and all following are from holes inside of the polygon.
	// The array for a part may be empty.
	InsetLayer(layer []data.LayerPart, offset data.Micrometer, insetCount int) [][][]data.LayerPart

	// Inset insets the given layer part.
	// The result is built the following way: [insetNr][insetParts]data.LayerPart
	//
	//  * Wall is the wall of the part. The first wall is the outer perimeter
	//  * InsetNum is the number of the inset (starting by the outer walls with 0)
	//    and all following are from holes inside of the polygon.
	// The array for a part may be empty.
	Inset(part data.LayerPart, offset data.Micrometer, insetCount int) [][]data.LayerPart

	Difference(part data.LayerPart, toRemove []data.LayerPart) (parts []data.LayerPart, ok bool)
}

// clipperClipper implements Clipper using the external clipper library.
type clipperClipper struct{}

// NewClipper returns a new instance of a polygon Clipper.
func NewClipper() Clipper {
	return &clipperClipper{}
}

// clipperPoint converts the GoSlice point representation to the
// representation which is used by the external clipper lib.
func clipperPoint(p data.MicroPoint) *clipper.IntPoint {
	return &clipper.IntPoint{
		X: clipper.CInt(p.X()),
		Y: clipper.CInt(p.Y()),
	}
}

// clipperPaths converts the GoSlice Paths representation
// to the representation which is used by the external clipper lib.
func clipperPaths(p data.Paths) clipper.Paths {
	var result clipper.Paths
	for _, path := range p {
		result = append(result, clipperPath(path))
	}

	return result
}

// clipperPath converts the GoSlice Path representation
// to the representation which is used by the external clipper lib.
func clipperPath(p data.Path) clipper.Path {
	var result clipper.Path
	for _, point := range p {
		result = append(result, clipperPoint(point))
	}

	return result
}

// microPoint converts the external clipper lib representation of a point
// to the representation which is used by GoSlice.
func microPoint(p *clipper.IntPoint) data.MicroPoint {
	return data.NewMicroPoint(data.Micrometer(p.X), data.Micrometer(p.Y))
}

// microPath converts the external clipper lib representation of a path
// to the representation which is used by GoSlice.
// The parameter simplify enables simplifying of the path using
// the default simplification settings.
func microPath(p clipper.Path, simplify bool) data.Path {
	var result data.Path
	for _, point := range p {
		result = append(result, microPoint(point))
	}

	if simplify {
		return result.Simplify(-1, -1)
	}
	return result
}

// microPaths converts the external clipper lib representation of paths
// to the representation which is used by GoSlice.
// The parameter simplify enables simplifying of the paths using
// the default simplification settings.
func microPaths(p clipper.Paths, simplify bool) data.Paths {
	var result data.Paths
	for _, path := range p {
		result = append(result, microPath(path, simplify))
	}
	return result
}

func (c clipperClipper) GenerateLayerParts(l data.Layer) (data.PartitionedLayer, bool) {
	polyList := clipper.Paths{}
	// convert all polygons to clipper polygons
	for _, layerPolygon := range l.Polygons() {
		var path = clipper.Path{}

		prev := 0
		// convert all points of this polygons
		for j, layerPoint := range layerPolygon {
			// ignore first as the next check would fail otherwise
			if j == 0 {
				path = append(path, clipperPoint(layerPolygon[0]))
				continue
			}

			// filter too near points
			// check this always with the previous point
			if layerPoint.Sub(layerPolygon[prev]).ShorterThanOrEqual(100) {
				continue
			}

			path = append(path, clipperPoint(layerPoint))
			prev = j
		}

		polyList = append(polyList, path)
	}

	if len(polyList) == 0 {
		return data.NewPartitionedLayer([]data.LayerPart{}, -1), true
	}

	cl := clipper.NewClipper(clipper.IoNone)
	cl.AddPaths(polyList, clipper.PtSubject, true)
	resultPolys, ok := cl.Execute2(clipper.CtUnion, clipper.PftEvenOdd, clipper.PftEvenOdd)
	if !ok {
		return nil, false
	}

	return data.NewPartitionedLayer(polyTreeToLayerParts(resultPolys)), true
}

func polyTreeToLayerParts(tree *clipper.PolyTree) ([]data.LayerPart, int) {
	var layerParts []data.LayerPart

	depth := 0
	var polysForNextRound []*clipper.PolyNode

	for _, c := range tree.Childs() {
		polysForNextRound = append(polysForNextRound, c)
	}
	for {
		if polysForNextRound == nil {
			break
		}
		thisRound := polysForNextRound
		polysForNextRound = nil

		for _, p := range thisRound {
			var holes data.Paths

			for _, child := range p.Childs() {
				// TODO: simplyfy, yes / no ??
				holes = append(holes, microPath(child.Contour(), false))
				for _, c := range child.Childs() {
					polysForNextRound = append(polysForNextRound, c)
				}
			}

			// TODO: simplify, yes / no ??
			layerParts = append(layerParts, data.NewUnknownLayerPart(microPath(p.Contour(), false), holes, depth))
		}

		depth++
	}

	depth--

	return layerParts, depth
}

func (c clipperClipper) InsetLayer(layer []data.LayerPart, offset data.Micrometer, insetCount int) [][][]data.LayerPart {
	var result [][][]data.LayerPart
	for _, part := range layer {
		result = append(result, c.Inset(part, offset, insetCount))
	}

	return result
}

func (c clipperClipper) Inset(part data.LayerPart, offset data.Micrometer, insetCount int) [][]data.LayerPart {
	var insets [][]data.LayerPart

	co := clipper.NewClipperOffset()

	for insetNr := 0; insetNr < insetCount; insetNr++ {
		// insets for the outline
		co.Clear()
		co.AddPaths(clipperPaths(data.Paths{part.Outline()}), clipper.JtSquare, clipper.EtClosedPolygon)
		co.AddPaths(clipperPaths(part.Holes()), clipper.JtSquare, clipper.EtClosedPolygon)

		co.MiterLimit = 2
		allNewInsets := co.Execute2(float64(-int(offset)*insetNr) - float64(offset/2))
		parts, _ := polyTreeToLayerParts(allNewInsets)
		insets = append(insets, parts)
	}

	return insets
}

func (c clipperClipper) Difference(part data.LayerPart, toRemove []data.LayerPart) (parts []data.LayerPart, ok bool) {
	cl := clipper.NewClipper(clipper.IoNone)
	cl.AddPath(clipperPath(part.Outline()), clipper.PtSubject, true)
	cl.AddPaths(clipperPaths(part.Holes()), clipper.PtSubject, true)

	for _, remove := range toRemove {
		cl.AddPath(clipperPath(remove.Outline()), clipper.PtClip, true)
		cl.AddPaths(clipperPaths(remove.Holes()), clipper.PtClip, true)
	}

	tree, ok := cl.Execute2(clipper.CtDifference, clipper.PftEvenOdd, clipper.PftEvenOdd)

	if !ok {
		return nil, ok
	}
	treeParts, _ := polyTreeToLayerParts(tree)
	return treeParts, ok
}
